{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FastDepends","text":"<p>FastDepends - FastAPI Dependency Injection system extracted from FastAPI and cleared of all HTTP logic. This is a small library which provides you with the ability to use lovely FastAPI interfaces in your own projects or tools.</p> <p>Thanks to fastapi and pydantic projects for this great functionality. This package is just a small change of the original FastAPI sources to provide DI functionality in a pure-Python way.</p> <p>Async and sync modes are both supported.</p>"},{"location":"#for-why","title":"For why?","text":"<p>This project should be extremely helpful to boost your not-FastAPI applications (even Flask, I know that u like some legacy).</p> <p>Also the project can be a core of your own framework for anything. Actually, it was build for my another project - Propan (and FastStream), check it to see full-featured FastDepends usage example.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>$ pip install fast-depends\n---&gt; 100%\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>There is no way to make Dependency Injection easier</p> <p>You can use this library without any frameworks in both sync and async code.</p> Async codeSync code <pre><code>import asyncio\n\nfrom fast_depends import Depends, inject\n\nasync def dependency(a: int) -&gt; int:\n    return a\n\n@inject\nasync def main(\n    a: int,\n    b: int,\n    c: int = Depends(dependency)\n) -&gt; float:\n    return a + b + c\n\nassert asyncio.run(main(\"1\", 2)) == 4.0\n</code></pre> <pre><code>from fast_depends import Depends, inject\n\ndef dependency(a: int) -&gt; int:\n    return a\n\n@inject\ndef main(\n    a: int,\n    b: int,\n    c: int = Depends(dependency)\n) -&gt; float:\n    return a + b + c\n\nassert main(\"1\", 2) == 4.0\n</code></pre> <p><code>@inject</code> decorator plays multiple roles at the same time:</p> <ul> <li>resolve Depends classes</li> <li>cast types according to Python annotation</li> <li>validate incoming parameters using pydantic</li> </ul> <p>Tip</p> <p>Synchronous code is fully supported in this package: without any <code>async_to_sync</code>, <code>run_sync</code>, <code>syncify</code> or any other tricks.</p> <p>Also, FastDepends casts functions' return values the same way, it can be very helpful in building your own tools.</p> <p>These are two main defferences from native FastAPI DI System.   </p>"},{"location":"#dependencies-overriding","title":"Dependencies Overriding","text":"<p>Also, FastDepends can be used as a lightweight DI container. Using it, you can easily override basic dependencies with application startup or in tests.</p> <pre><code>from typing import Annotated\nfrom fast_depends import Depends, dependency_provider, inject\n\ndef abc_func() -&gt; int:\n    raise 2\n\ndef real_func() -&gt; int:\n    return 1\n\n@inject\ndef func(\n    dependency: Annotated[int, Depends(abc_func)]\n) -&gt; int:\n    return dependency\n\nwith dependency_provider.scope(abc_func, real_func):\n    assert func() == 1\n</code></pre> <p><code>dependency_provider</code> in this case is just a default container already declared in the library. But you can use your own the same way:</p> <pre><code>from typing import Annotated\nfrom fast_depends import Depends, Provider, inject\n\nprovider = Provider()\n\ndef abc_func() -&gt; int:\n    raise 2\n\ndef real_func() -&gt; int:\n    return 1\n\n@inject(dependency_overrides_provider=provider)\ndef func(\n    dependency: Annotated[int, Depends(abc_func)]\n) -&gt; int:\n    return dependency\n\nwith provider.scope(abc_func, real_func):\n    assert func() == 1\n</code></pre> <p>This way you can inherit the basic <code>Provider</code> class and define any extra logic you want!</p>"},{"location":"#custom-fields","title":"Custom Fields","text":"<p>If you wish to write your own FastAPI or another closely by architecture tool, you should define your own custom fields to specify application behavior.</p> <p>Custom fields can be used to adding something specific to a function arguments (like a BackgroundTask) or parsing incoming objects special way. You able decide by own, why and how you will use these tools.</p> <p>FastDepends grants you this opportunity a very intuitive and comfortable way.</p> <pre><code>from fast_depends import inject\nfrom fast_depends.library import CustomField\n\nclass Header(CustomField):\n    def use(self, /, **kwargs: AnyDict) -&gt; AnyDict:\n        kwargs = super().use(**kwargs)\n        kwargs[self.param_name] = kwargs[\"headers\"][self.param_name]\n        return kwargs\n\n@inject\ndef my_func(header_field: int = Header()):\n    return header_field\n\nassert my_func(\n    headers={\"header_field\": \"1\"}\n) == 1\n</code></pre> <p>More details you can find at advanced tutorial</p>"},{"location":"alternatives/","title":"Some more featured DI python libraries","text":"<p><code>FastDepend</code> is a very small toolkit to achieve one point: provide you with opportunity to use FastAPI <code>Depends</code> and typecasting everywhere.</p> <p>Sometimes, more complex tools are required. In these cases I can recommend you to take a look at the following projects</p>"},{"location":"alternatives/#dishka","title":"Dishka","text":"<p>Cute DI framework with scopes and agreeable API.</p> <p>This library provides IoC container that\u2019s genuinely useful. If you\u2019re exhausted from endlessly passing objects just to create other objects, only to have those objects create even more \u2014 you\u2019re not alone, and we have a solution. Not every project requires IoC container, but take a look at what we offer.</p> <p>Unlike other tools, <code>dishka</code> focuses only on dependency injection without trying to solve unrelated tasks. It keeps DI in place without cluttering your code with global variables and scattered specifiers.</p> <p>Key features:</p> <ul> <li>Scopes. Any object can have a lifespan for the entire app, a single request, or even more fractionally. Many frameworks either lack scopes completely or offer only two. Here, you can define as many scopes as needed.</li> <li>Finalization. Some dependencies, like database connections, need not only to be created but also carefully released. Many frameworks lack this essential feature.</li> <li>Modular providers. Instead of creating many separate functions or one large class, you can split factories into smaller classes for easier reuse.</li> <li>Clean dependencies. You don\u2019t need to add custom markers to dependency code just to make it visible to the library.</li> <li>Simple API. Only a few objects are needed to start using the library.</li> <li>Framework integrations. Popular frameworks are supported out of the box. You can simply extend it for your needs.</li> </ul> <p>Speed. The library is fast enough that performance is not a concern. In fact, it outperforms many alternatives.</p>"},{"location":"alternatives/#di","title":"DI","text":"<p><code>di</code> is a modern dependency injection toolkit, modeled around the simplicity of FastAPI's dependency injection.</p> <p>Key features:</p> <ul> <li>Intuitive: simple API, inspired by FastAPI</li> <li>Auto-wiring: <code>di</code> also supports auto-wiring using type annotations</li> <li>Scopes: inspired by <code>pytest scopes</code>, but defined by users</li> <li>Composable: decoupled internal APIs give you the flixibility to customize wiring, execution and binding.</li> <li>Performance: <code>di</code> can execute dependencies in parallel and cache results ins scopes.</li> </ul>"},{"location":"alternatives/#dependency-injector","title":"Dependency Injector","text":"<p>Dependency Injector is a dependency injection framework for Python.</p> <p>It helps implementing the dependency injection principle.</p> <p>Key features:</p> <ul> <li>Providers</li> <li>Overriding on the fly</li> <li>Configuration (yaml, ini, json, pydantic, .env, etc)</li> <li>Resources</li> <li>Containers</li> <li>Wiring</li> <li>Asynchronous</li> <li>Typing</li> <li>Performance</li> <li>Maturity</li> </ul>"},{"location":"contributing/","title":"Developing","text":"<p>If you already cloned the repository and you know that you need to deep dive in the code, here are some guidelines to set up your environment.</p>"},{"location":"contributing/#virtual-environment-with-venv","title":"Virtual environment with <code>venv</code>","text":"<p>You can create a virtual environment in a directory using Python's <code>venv</code> module:</p> <pre><code>python -m venv venv\n</code></pre> <p>That will create a directory <code>./venv/</code> with the Python binaries and then you will be able to install packages for that isolated environment.</p>"},{"location":"contributing/#activate-the-environment","title":"Activate the environment","text":"<p>Activate the new environment with:</p> <pre><code>source ./venv/bin/activate\n</code></pre>"},{"location":"contributing/#install-dependencies","title":"Install dependencies","text":"pipuv <p>Make sure you have the latest pip version on your virtual environment to</p> <pre><code>python -m pip install -U pip\n</code></pre> <p>After activating the environment as described above:</p> <pre><code>pip install --group dev -e .\n</code></pre> <pre><code>uv sync --group dev\n</code></pre> <p>It will install all the dependencies and your local FastDepends in your local environment.</p>"},{"location":"contributing/#using-your-local-fastdepends","title":"Using your local FastDepends","text":"<p>If you create a Python file that imports and uses FastDepends, and run it with the Python from your local environment, it will use your local FastDepends source code.</p> <p>And if you update that local FastDepends source code, as it is installed with <code>-e</code>, when you run that Python file again, it will use the fresh version of FastDepends you just edited.</p> <p>That way, you don't have to \"install\" your local version to be able to test every change.</p>"},{"location":"contributing/#tests","title":"Tests","text":""},{"location":"contributing/#pytests","title":"Pytests","text":"<p>To run tests with your current FastDepends application and Python environment use:</p> <pre><code>pytest tests\n# or\nbash ./scripts/test.sh\n# with coverage output\nbash ./scripts/test-cov.sh\n</code></pre>"},{"location":"usages/","title":"Potential Usages","text":"<p><code>FastDepends</code> is a great instrument to integrate with any frameworks you are already using. It can also be a part of your own tools and frameworks (HTTP or not* )</p> <p>There are some usage examples with popular Python HTTP Frameworks:</p> FlaskStarlette <pre><code>from flask import Flask\nfrom pydantic import Field\n\nfrom fast_depends import Depends, inject\n\napp = Flask(__name__)\n\ndef get_user(user_id: int = Field(..., alias=\"id\")):\n    return f\"user {user_id}\"\n\n@app.get(\"/&lt;id&gt;\")\n@inject\ndef hello(user: str = Depends(get_user)):\n    return f\"&lt;p&gt;Hello, {user}!&lt;/p&gt;\"\n</code></pre> <pre><code># Is that FastAPI???\nfrom pydantic import Field\nfrom starlette.applications import Starlette\nfrom starlette.responses import PlainTextResponse\nfrom starlette.routing import Route\n\nfrom fast_depends import Depends, inject\n\ndef unwrap_path(func):\n    async def wrapper(request):  # unwrap incoming params to **kwargs here\n        return await func(**request.path_params)\n    return wrapper\n\nasync def get_user(user_id: int = Field(..., alias=\"id\")):\n    return f\"user {user_id}\"\n\n@unwrap_path\n@inject  # cast incoming kwargs here\nasync def hello(user: str = Depends(get_user)):\n    return PlainTextResponse(f\"Hello, {user}!\")\n\napp = Starlette(debug=True, routes=[\n    Route(\"/{id}\", hello)\n])\n</code></pre> <p>As you can see above, library, some middlewares and supporting classes... And you can use the whole power of typed Python everywhere.</p> <p>Tip</p> <p><code>FastDepends</code> raises <code>pydantic.error_wrappers.ValidationError</code> at type casting exceptions.</p> <p>You need to handle them and wrap them in your own response with your custom middleware if you want to use it in production.</p> <p>Note</p> <p> If you are interested in using <code>FastDepends</code> in other frameworks, please take a look at my own Propan framework for working with various Message Brokers.</p>"},{"location":"works/","title":"How it works","text":"<p>At first, I suppose, we need to discuss about this tool's key concept.</p> <p>It is very simple:</p> <ol> <li>At your code's initialization time <code>FastDepends</code> builds special pydantic model with your function's expected arguments as a model fields, builds the dependencies graph</li> <li>At runtime <code>FastDepends</code> grabs all incoming functions' <code>*args, **kwargs</code> and initializes functions' representation models with them</li> <li>At the next step <code>FastDepends</code> execute functions' dependensies with the model fields as an arguments, calls the original function</li> <li>Finally, <code>FastDepends</code> catches functions' outputs and casts it to expected <code>return</code> type</li> </ol> <p>This is pretty close to the following code:</p> <pre><code>from pydantic import BaseModel\n\nfrom fast_depends import Depends\n\ndef simple_dependency(a: int, **kwargs):\n    return a\n\ndef my_function(a: int, b: int, d = Depends(simple_dependency)) -&gt; float:\n    return a + b + d\n\n# Declare function representation model\nclass MyFunctionRepresentation(BaseModel):\n    a: int  # used twice: for original function and dependency\n    b: int\n\nkwargs = {\"a\": 1, \"b\": \"3\"}\n\n# Cast incomint arguments\narguments_model = MyFunctionRepresentation(**kwargs)\n\n# Use them\nnew_kwargs = arguments_model.model_dump()\nbase_response = my_function(\n    **new_kwargs,\n    d=simple_dependency(**new_kwargs)\n)\n\nclass ResponseModel(BaseModel):\n    field: float\n\n# Cast response\nreal_response = ResponseModel(field=base_response).field\n</code></pre> <p>Note</p> <p>It is not the real code, but generally <code>FastDepends</code> works this way</p> <p>So, the biggest part of the <code>FastDepends</code> code execution happens on application startup. At runtime the library just casts types to already built models. It works really fast. Generally, the library works with the same speed as the <code>pydantic</code> - the main dependency.</p> <p>On the other hand, working with only <code>*args, **kwargs</code> allows the library to be independent from other frameworks, business domains, technologies, etc. You are free to decide for yourself, how exactly to use this tool.</p>"},{"location":"advanced/","title":"CustomField","text":"<p>Packages developers</p> <p>This is the part of documentation will talks you about some features, that can be helpful to develop your own packages with <code>FastDepends</code></p>"},{"location":"advanced/#custom-arguments-field","title":"Custom Arguments Field","text":"<p>If you wish to write your own FastAPI or another closely by architecture tool, you should define your own custom fields to specify application behavior. At FastAPI these fields are:</p> <ul> <li>Body</li> <li>Path</li> <li>Query</li> <li>Header</li> <li>Cookie</li> <li>Form</li> <li>File</li> <li>Security</li> </ul> <p>Custom fields can be used to adding something specific to a function arguments (like a BackgroundTask) or parsing incoming objects special way. You able decide by own, why and how you will use these tools.</p> <p><code>FastDepends</code> grants you this opportunity a very intuitive and comfortable way.</p>"},{"location":"advanced/#lets-write-header","title":"Let's write Header","text":"<p>As an example, will try to implement FastAPI Header field</p> <pre><code>from fast_depends.library import CustomField\n\nclass Header(CustomField):\n    def use(self, /, **kwargs):\n        kwargs = super().use(**kwargs)\n        kwargs[self.param_name] = kwargs[\"headers\"][self.param_name]\n        return kwargs\n</code></pre> <p>Just import <code>fast_depends.library.CustomField</code> and implements <code>use</code> (async or sync) method. That's all. We already have own Header field to parse kwargs the special way.</p>"},{"location":"advanced/#header-usage","title":"Header usage","text":"<p>Now we already can use the Header field</p> <pre><code>from fast_depends import inject\n\n@inject\ndef my_func(header_field: int = Header()):\n    return header_field\n\nassert h(\n    headers={\"header_field\": \"1\"}\n) == 1\n</code></pre> <p>As we defined, Header parse incoming headers kwargs field, get a parameter by name and put it to original function as an argument.</p>"},{"location":"advanced/#more-details","title":"More details","text":"<p><code>CustomField</code> has some fields you should know about</p> <pre><code>class CustomField:\n    param_name: str\n    cast: bool\n    required: bool\n</code></pre> <ul> <li><code>param_name</code> - an original function argument name to replace by your field instance. It was <code>header_field</code> at the example above.</li> <li><code>required</code> - if CustomField is required, raises <code>pydantic.error_wrappers.ValidationError</code> if it is not present at final kwargs</li> <li><code>cast</code> - specify the typecasting behavior. Use False to disable pydantic typecasting for fields using with your CustomField</li> </ul> <pre><code>class Header(CustomField):\n    def __init__(self):\n        super().__init__(cast=True)\n\nclass NotCastHeader(CustomField):\n    def __init__(self):\n        super().__init__(cast=False)\n\ndef func(\n    h1: int = Header(),        # &lt;-- casts to int\n    h2: int = NotCastHeader()  # &lt;-- just an annotation\n): ...\n</code></pre> <p>Note</p> <p>Pydantic understands only python-native annotation or Pydantic classes. If users will annotate your fields by other classes, you should set <code>cast=False</code> to avoid pydantic exceptions.</p> <pre><code>def use(self, **kwargs: AnyDict) -&gt; AnyDict: ...\n</code></pre> <p>Your CustimField objects receive casted to kwargs an original function incoming arguments at <code>use</code> method. Returning from the <code>use</code> method dict replace an original one. Original function will be executed with a returned from your fields kwargs. Be accurate with.</p> <p>And one more time:</p> <pre><code>original_kwargs = { \"headers\": { \"field\": 1 }}\n\nnew_kwargs = Header().set_param_name(\"field\").use(**kwargs)\n# new_kwargs = {\n#   \"headers\": { \"field\": 1 },\n#   \"field\": 1  &lt;-- new field from Header\n# }\n\noriginal_function(**new_kwargs)\n</code></pre> <p>I hope it was clearly enough right now.</p> <p>Also, custom fields using according their definition: from left to right. Next Custom Fields kwargs is a return of previous.</p> <p>An example:</p> <pre><code>@inject\ndef func(field1 = Header(), field2 = Header()): ...\n</code></pre> <p>field2 incoming kwargs is an output of field1.use() </p>"},{"location":"advanced/starlette/","title":"Let's write some code","text":"<p>Now we take the starlette example from usages and specify it to use Path now.</p>"},{"location":"advanced/starlette/#handle-request-specific-fields","title":"Handle request specific fields","text":"<p>First of all, Starlette pass to a handler the only one argument - <code>request</code> To use them with <code>FastDepends</code> we need unwrap <code>request</code> to kwargs.</p> <pre><code>from starlette.applications import Starlette\n\n\ndef wrap_starlette(func):\n    async def wrapper(request):\n        return await inject(func)(\n            request=request\n        )\n    return wrapper\n</code></pre> <p>Also, we wraps an original handler to <code>fast_depends.inject</code> too at 3 line</p>"},{"location":"advanced/starlette/#declare-custom-field","title":"Declare Custom Field","text":"<p>Next step, define Path custom field</p> <pre><code>from starlette.responses import PlainTextResponse\n\n\nclass Path(CustomField):\n    def use(self, /, *, request, **kwargs):\n        return {\n            **super().use(request=request, **kwargs),\n            self.param_name: request.path_params.get(self.param_name)\n        }\n</code></pre>"},{"location":"advanced/starlette/#usage-with-the-starlette","title":"Usage with the Starlette","text":"<p>And use it at our Starlette application: <pre><code>from fast_depends import inject\nfrom fast_depends.library import CustomField\n\n\nasync def hello(user: str = Path()):\n    return PlainTextResponse(f\"Hello, {user}!\")\n\napp = Starlette(debug=True, routes=[\n    Route(\"/{user}\", hello)\n])\n</code></pre></p> <p>Depends is working as expected too</p> <pre><code>def get_user(user_id: int = Path()):\n    return f\"user {user_id}\"\n\n@wrap_starlette\nasync def hello(user: str = Depends(get_user)):\n    return PlainTextResponse(f\"Hello, {user}!\")\n\napp = Starlette(debug=True, routes=[\n    Route(\"/{user_id}\", hello)\n])\n</code></pre> <p>As an Annotated does <pre><code>@wrap_starlette\nasync def get_user(user: Annotated[int, Path()]):\n    return PlainTextResponse(f\"Hello, {user}!\")\n</code></pre></p>"},{"location":"advanced/starlette/#full-example","title":"Full example","text":"<pre><code>from starlette.applications import Starlette\nfrom starlette.responses import PlainTextResponse\nfrom starlette.routing import Route\n\nfrom fast_depends import inject\nfrom fast_depends.library import CustomField\n\nclass Path(CustomField):\n    def use(self, /, *, request, **kwargs):\n        return {\n            **super().use(request=request, **kwargs),\n            self.param_name: request.path_params.get(self.param_name)\n        }\n\ndef wrap_starlette(func):\n    async def wrapper(request):\n        return await inject(func)(\n            request=request\n        )\n    return wrapper\n\n@wrap_starlette\nasync def hello(user: str = Path()):\n    return PlainTextResponse(f\"Hello, {user}!\")\n\napp = Starlette(debug=True, routes=[\n    Route(\"/{user}\", hello)\n])\n</code></pre> <p>The code above works \"as it\". You can copy it and declare other Header, Cookie, Query fields by yourself. Just try, it's fun!</p>"},{"location":"tutorial/","title":"Quickstart","text":"<p>I suppose, if you are already here, you are exactly known about this library usage.</p> <p>It is using the same way as FastAPI is.</p> <p>But, I can remember you, if it's necessary.</p>"},{"location":"tutorial/#basic-usage","title":"Basic usage","text":"SyncAsync <pre><code>from fast_depends import Depends, inject\n\ndef simple_dependency(a: int, b: int = 3):\n    return a + b\n\n@inject\ndef method(a: int, d: int = Depends(simple_dependency)):\n    return a + d\n\nassert method(\"1\") == 5\n</code></pre> <pre><code>import asyncio\n\nfrom fast_depends import Depends, inject\n\nasync def simple_dependency(a: int, b: int = 3):\n    return a + b\n\ndef another_dependency(a: int):\n    return a\n\n@inject\nasync def method(\n    a: int,\n    b: int = Depends(simple_dependency),\n    c: int = Depends(another_dependency),\n):\n    return a + b + c\n\nassert asyncio.run(method(\"1\")) == 6\n</code></pre> <p>Be accurate</p> <p>At async code we can use sync and async dependencies both, but at sync runtime only sync dependencies are available.</p> <p>First step: we need to declare our dependency: it can be any Callable object.</p> Callable <p>\"Callable\" - object is able to be \"called\". It can be any function, class, or class method.</p> <p>Another words: if we can write following the code <code>my_object()</code> - <code>my_object</code> is \"Callable\"</p> SyncAsync <pre><code>@inject\ndef method(a: int, d: int = Depends(simple_dependency)):\n    return a + d\n</code></pre> <pre><code>@inject\nasync def method(\n    a: int,\n    b: int = Depends(simple_dependency),\n    c: int = Depends(another_dependency),\n):\n</code></pre> <p>Second step: declare dependency required with <code>Depends</code></p> SyncAsync <pre><code>@inject\ndef method(a: int, d: int = Depends(simple_dependency)):\n    return a + d\n\nassert method(\"1\") == 5\n</code></pre> <pre><code>@inject\nasync def method(\n    a: int,\n    b: int = Depends(simple_dependency),\n    c: int = Depends(another_dependency),\n):\n    return a + b + c\n</code></pre> <p>Last step: just use the dependencies calling result!</p> <p>That was easy, isn't it?</p> <p>Auto @inject</p> <p>At the code above you can note, that original <code>Depends</code> functions wasn't decorated by <code>@inject</code>.</p> <p>It's true: all dependencies are decorated by default at using. Keep it at your mind.</p>"},{"location":"tutorial/#nested-dependencies","title":"Nested Dependencies","text":"<p>Dependencies are also able to contain their own dependencies. There is nothing unexpected with this case: just declare <code>Depends</code> requirement at original dependency function.</p> SyncAsync <pre><code>from fast_depends import Depends, inject\n\ndef another_dependency(a: int):\n    return a * 2\n\ndef simple_dependency(a: int, b: int = Depends(another_dependency)): # (1)\n    return a + b\n\n@inject\ndef method(\n    a: int,\n    b: int = Depends(another_dependency),\n    c: int = Depends(simple_dependency)\n):\n    return a + b + c\n\nassert method(\"1\") == 6\n</code></pre> <ol> <li>Call another_dependency here</li> </ol> <pre><code>import asyncio\n\nfrom fast_depends import Depends, inject\n\ndef another_dependency(a: int):\n    return a * 2\n\nasync def simple_dependency(a: int, b: int = Depends(another_dependency)): # (1)\n    return a + b\n\n@inject\nasync def method(\n    a: int,\n    b: int = Depends(simple_dependency),\n    c: int = Depends(another_dependency),\n):\n    return a + b + c\n\nassert asyncio.run(method(\"1\")) == 6\n</code></pre> <ol> <li>Call another_dependency here</li> </ol> <p>Cache</p> <p>At the examples above <code>another_dependency</code> was called AT ONCE!. <code>FastDepends</code> caches all dependencies responses throw ONE <code>@inject</code> callstask. It means, that all nested dependencies give a one-time cached response. But, with different injected function calls, cache will differ too.</p> <p>To disable that behavior, just use <code>Depends(..., cache=False)</code>. This way dependency will be executed each time.</p>"},{"location":"tutorial/#dependencies-type-casting","title":"Dependencies type casting","text":"<p>If you remember, <code>FastDepends</code> casts function <code>return</code> too. This means, dependency output will be casted twice: at dependency function out and at the injector in. Nothing bad, if they are the same type, nothing overhead occurs. Just keep it in your mind. Or don't... My work is done anyway.</p> <pre><code>from fast_depends import inject, Depends\n\ndef simple_dependency(a: int, b: int = 3) -&gt; str:\n    return a + b  # cast 'return' to str first time\n\n@inject\ndef method(a: int, d: int = Depends(simple_dependency)):\n    # cast 'd' to int second time\n    return a + d\n\nassert method(\"1\") == 5\n</code></pre> <p>Also, <code>return</code> type will be cached. If you are using this dependency at <code>N</code> functions, cached return will be casted <code>N</code> times.</p> <p>To avoid this problem use mypy to check types at your project or just be accurate with your outer annotations.</p>"},{"location":"tutorial/annotated/","title":"Using Annotated","text":""},{"location":"tutorial/annotated/#why","title":"Why?","text":"<p>Using <code>Annotated</code> has several benefits, one of the main ones is that now the parameters of your functions with <code>Annotated</code> would not be affected at all.</p> <p>If you call those functions in other places in your code, the actual default values will be kept, your editor will help you notice missing required arguments, Python will require you to pass required arguments at runtime, you will be able to use the same functions for different things and with different libraries.</p> <p>Because <code>Annotated</code> is standard Python, you still get all the benefits from editors and tools, like autocompletion, inline errors, etc.</p> <p>One of the biggest benefits is that now you can create <code>Annotated</code> dependencies that are then shared by multiple path operation functions, this will allow you to reduce a lot of code duplication in your codebase, while keeping all the support from editors and tools.</p>"},{"location":"tutorial/annotated/#example","title":"Example","text":"<p>For example, you could have code like this:</p> <pre><code>from pydantic import BaseModel, PositiveInt\n\nfrom fast_depends import Depends, inject\n\nclass User(BaseModel):\n    user_id: PositiveInt\n\ndef get_user(user: id) -&gt; User:\n    return User(user_id=user)\n\n@inject\ndef do_smth_with_user(user: User = Depends(get_user)):\n    ...\n\n@inject\ndef do_another_smth_with_user(user: User = Depends(get_user)):\n    ...\n</code></pre> <p>There's a bit of code duplication for the dependency: <pre><code>user: User = Depends(get_user)\n</code></pre></p> <p>...the bigger the codebase, the more noticeable it is.</p> <p>Now you can create an annotated dependency once, like this:</p> <pre><code>CurrentUser = Annotated[User, Depends(get_user)]\n</code></pre> <p>And then you can reuse this <code>Annotated</code> dependency:</p> <pre><code>from typing import Annotated\nfrom pydantic import BaseModel, PositiveInt\nfrom fast_depends import Depends, inject\n\nclass User(BaseModel):\n    user_id: PositiveInt\n\ndef get_user(user: id) -&gt; User:\n    return User(user_id=user)\n\nCurrentUser = Annotated[User, Depends(get_user)]\n\n@inject\ndef do_smth_with_user(user: CurrentUser):\n    ...\n\n@inject\ndef do_another_smth_with_user(user: CurrentUser):\n    ...\n</code></pre> <p>...and <code>CurrentUser</code> has all the typing information as <code>User</code>, so your editor will work as expected (autocompletion and everything), and FastDepends will be able to understand the dependency defined in <code>Annotated</code>. </p>"},{"location":"tutorial/annotated/#annotatable-variants","title":"Annotatable variants","text":"<p>You able to use <code>Field</code> and <code>Depends</code> with <code>Annotated</code> as well</p> <pre><code>from typing import Annotated\nfrom pydantic import Field\nfrom fast_depends import Depends\n\nCurrentUser = Annotated[User, Depends(get_user)]\nMaxLenField = Annotated[str, Field(..., max_length=\"32\")]\n</code></pre>"},{"location":"tutorial/annotated/#limitations","title":"Limitations","text":"<p>Python has a very structured function arguments declaration rules.</p> <pre><code>def function(\n    required_positional_or_keyword_arguments_first,\n    default_positional_or_keyword_arguments_second = None.\n    *all_unrecognized_positional_arguments,\n    required_keyword_only_arguments,\n    default_keyword_only_arguments = None,\n    **all_unrecognized_keyword_arguments,\n): ...\n</code></pre> <p>Warning</p> <p>You can not declare arguments without default after default arguments was declared</p> <p>So</p> <pre><code>def func(user_id: int, user: CurrentUser): ...\n</code></pre> <p>... is a valid python code</p> <p>But <pre><code>def func(user_id: int | None = None, user: CurrentUser): ...  # invalid code!\n</code></pre></p> <p>... is not! You can't use the <code>Annotated</code> only argument after default argument declaration.</p> <p>There are some ways to write code above correct way:</p> <p>You can use <code>Annotated</code> with a default value</p> <pre><code>def func(user_id: int | None = None, user: CurrentUser = None): ...\n</code></pre> <p>Or you you can use <code>Annotated</code> with all arguments</p> <pre><code>UserId = Annotated[int, Field(...)]  # Field(...) is a required\ndef func(user_id: UserId, user: CurrentUser): ...\n</code></pre> <p>Also, from the Python view, the following code</p> <pre><code># Potential invalid code!\ndef func(user: CurrentUser, user_id: int | None = None): ...\n</code></pre> <p>But, FastDepends parse positional arguments according their position.</p> <p>So, calling the function above this way <pre><code>func(1)\n</code></pre></p> <p>Will parses as the following kwargs <pre><code>{ \"user\": 1 }\n</code></pre> And raises error</p> <p>But, named calling will be correct <pre><code>func(user_id=1)  # correct calling\n</code></pre></p> <p>I really recommend do not use <code>Annotated</code> as a positional argument</p> <p>The best way to avoid all misunderstanding between you and Python - use <code>pydantic.Field</code> with <code>Annotated</code> everywhere</p> <p>Like in the following example</p> <pre><code>def func(user_id: Annotated[int, Field(...)], user: CurrentUser): ...\n</code></pre>"},{"location":"tutorial/classes/","title":"Classes as Dependencies","text":""},{"location":"tutorial/classes/#callable-remember","title":"\"Callable\", remember?","text":"<pre><code>class MyClass: pass\n\nMyClass()       # It is a \"call\"!      1-st call\n\n\nclass MyClass:\n    def __call__(): pass\n\nm = MyClass()\nm()             # It is a \"call\" too!  2-nd call\n\n\nclass MyClass:\n    @classmethod\n    def f(): pass\n\nMyClass.f()     # Yet another \"call\"!  3-rd call\n\n\nclass MyClass\n    def f(self): pass\n\nMyClass().f()   # \"call\"?              4-th call\n</code></pre> <p>Yep, all of these examples can be used as a dependency!</p>"},{"location":"tutorial/classes/#init-1-st-call","title":"INIT (1-st call)","text":"<p>You can use class initializer as a dependency. This way, object of this class will be the type of your dependency:</p> <pre><code>from typing import Any\n\nfrom fast_depends import Depends, inject\n\nclass MyDependency:\n    def __init__(self, a: int):\n        self.field = a\n\n@inject\ndef func(d: Any = Depends(MyDependency)):\n    return d.field\n\nassert func(a=3) == 3\n</code></pre> <p>Warning</p> <p>You should use <code>Any</code> annotation if <code>MyDependency</code> is not a <code>pydantic.BaseModel</code> subclass. Using <code>MyDependency</code> annotation raises <code>ValueError</code> exception at code initialization time as the pydantic can't cast any value to not-pydantic class.</p>"},{"location":"tutorial/classes/#call-2-nd-call","title":"CALL (2-nd call)","text":"<p>If you wish to specify your dependency behavior earlier, you can use <code>__call__</code> method of already initialized class object.</p> <pre><code>from fast_depends import Depends, inject\n\nclass MyDependency:\n    def __init__(self, a: int):\n        self.field = a\n\n    def __call__(self, b: int):\n        return self.field + b\n\n@inject\ndef func(d: int = Depends(MyDependency(3))):\n    return d\n\nassert func(b=3) == 6\n</code></pre>"},{"location":"tutorial/classes/#classmethod-or-staticmethod-3-rd-call","title":"CLASSMETHOD or STATICMETHOD (3-rd call)","text":"<p>Also, you can use classmethods or staticmethod as dependencies. It can be helpful with some OOP patterns (Strategy as an example).</p> <pre><code>from fast_depends import Depends, inject\n\nclass MyDependency:\n    @staticmethod\n    def dep(a: int):\n        return a ** 2\n\n@inject\ndef func(d: int = Depends(MyDependency.dep)):\n    return d\n\nassert func(a=3) == 9\n</code></pre>"},{"location":"tutorial/classes/#any-method-4-th-call","title":"ANY METHOD (4-th call)","text":"<pre><code>from fast_depends import Depends, inject\n\nclass MyDependency:\n    def __init__(self, a):\n        self.field = a\n\n    def dep(self, a: int):\n        return self.field + a\n\n@inject\ndef func(d: int = Depends(MyDependency(3).dep)):\n    return d\n\nassert func(a=3) == 6\n</code></pre> <p>Async</p> <p>Only 3-rd and 4-th call methods are able to be <code>async</code> type</p>"},{"location":"tutorial/overrides/","title":"Testing Dependencies with Overrides","text":""},{"location":"tutorial/overrides/#overriding-dependencies-during-testing","title":"Overriding dependencies during testing","text":"<p>There are some scenarios where you might want to override a dependency during testing.</p> <p>You don't want the original dependency to run (nor any of the sub-dependencies it might have).</p> <p>Instead, you want to provide a different dependency that will be used only during tests (possibly only some specific tests), and will provide a value that can be used where the value of the original dependency was used.</p>"},{"location":"tutorial/overrides/#use-cases-external-service","title":"Use cases: external service","text":"<p>An example could be that you have an external authentication provider that you need to call.</p> <p>You send it a token and it returns an authenticated user.</p> <p>This provider might be charging you per request, and calling it might take some extra time than if you had a fixed mock user for tests.</p> <p>You probably want to test the external provider once, but not necessarily call it for every test that runs.</p> <p>In this case, you can override the dependency that calls that provider, and use a custom dependency that returns a mock user, only for your tests.</p>"},{"location":"tutorial/overrides/#use-the-fast_dependsdependency_provider-object","title":"Use the <code>fast_depends.dependency_provider</code> object","text":"<p>For these cases, your FastDepends library has an object <code>dependency_provider</code> with <code>dependency_overrides</code> attribute, it is a simple <code>dict</code>.</p> <p>To override a dependency for testing, you put as a key the original dependency (a function), and as the value, your dependency override (another function).</p> <p>And then FastDepends will call that override instead of the original dependency.</p> <pre><code>from fast_depends import Depends, dependency_provider, inject\n\ndef original_dependency():\n    raise NotImplementedError()\n\ndef override_dependency():\n    return 1\n\n@inject\ndef func(d = Depends(original_dependency)):\n    return d\n\ndependency_provider.override(original_dependency, override_dependency)\n# or\ndependency_provider[original_dependency] = override_dependency\n\ndef test():\n    assert func() == 1\n</code></pre>"},{"location":"tutorial/overrides/#use-pytestfixture","title":"Use <code>pytest.fixture</code>","text":"<p><code>dependency_provider</code> is a library global object. Override dependency at one place, you override it everywhere.</p> <p>So, if you don't wish to override dependency everywhere, I extremely recommend to use the following fixture for your tests</p> <pre><code>import pytest\n\nfrom fast_depends import Depends, dependency_provider, inject\n\n# Base code\ndef base_dep():\n    return 1\n\ndef override_dep():\n    return 2\n\n@inject\ndef func(d = Depends(base_dep)):\n    return d\n\n# Tests\n@pytest.fixture\ndef provider():\n    yield dependency_provider\n    dependency_provider.clear() # (1)!\n\ndef test_sync_overide(provider):\n    provider.override(base_dep, override_dep)\n    assert func() == 2\n</code></pre> <ol> <li>Drop all overridings</li> </ol> <p>Tip</p> <p>Alternatively, you can create you own dependency provider in pass it in the functions you want.</p> <pre><code>from typing import Annotated\nfrom fast_depends import Depends, Provider, inject\n\nprovider = Provider()\n\ndef abc_func() -&gt; int:\n    raise 2\n\ndef real_func() -&gt; int:\n    return 1\n\n@inject(dependency_overrides_provider=provider)\ndef func(\n    dependency: Annotated[int, Depends(abc_func)]\n) -&gt; int:\n    return dependency\n\nwith provider.scope(abc_func, real_func):\n    assert func() == 1\n</code></pre>"},{"location":"tutorial/validations/","title":"Pydantic Field","text":"<p><code>FastDepends</code> is able to use <code>pydantic.Field</code> as a default parameter to validate incoming argument</p> <pre><code>from pydantic import Field\nfrom fast_depends import inject\n\n@inject\ndef func(a: str = Field(..., max_length=32)):\n    ...\n</code></pre> <p>Pydantic Documentation</p> <p>To get more information and usage examples, please visit official pydantic documentation</p> <p>All available fields are:</p> <ul> <li><code>default</code>: (a positional argument) the default value of the field.     Since the <code>Field</code> replaces the field's default, this first argument can be used to set the default.     Use ellipsis (<code>...</code>) to indicate the field is required.</li> <li><code>default_factory</code>: a zero-argument callable that will be called when a default value is needed for this field.     Among other purposes, this can be used to set dynamic default values.     It is forbidden to set both <code>default</code> and <code>default_factory</code>.</li> <li><code>alias</code>: the public name of the field</li> <li><code>const</code>: this argument must be the same as the field's default value if present.</li> <li><code>gt</code>: for numeric values (<code>int</code>, <code>float</code>, <code>Decimal</code>), adds a validation of \"greater than\" and an annotation   of <code>exclusiveMinimum</code> to the JSON Schema</li> <li><code>ge</code>: for numeric values, this adds a validation of \"greater than or equal\" and an annotation of <code>minimum</code> to the   JSON Schema</li> <li><code>lt</code>: for numeric values, this adds a validation of \"less than\" and an annotation of <code>exclusiveMaximum</code> to the   JSON Schema</li> <li><code>le</code>: for numeric values, this adds a validation of \"less than or equal\" and an annotation of <code>maximum</code> to the   JSON Schema</li> <li><code>multiple_of</code>: for numeric values, this adds a validation of \"a multiple of\" and an annotation of <code>multipleOf</code> to the   JSON Schema</li> <li><code>max_digits</code>: for <code>Decimal</code> values, this adds a validation to have a maximum number of digits within the decimal. It   does not include a zero before the decimal point or trailing decimal zeroes.</li> <li><code>decimal_places</code>: for <code>Decimal</code> values, this adds a validation to have at most a number of decimal places allowed. It   does not include trailing decimal zeroes.</li> <li><code>min_items</code>: for list values, this adds a corresponding validation and an annotation of <code>minItems</code> to the   JSON Schema</li> <li><code>max_items</code>: for list values, this adds a corresponding validation and an annotation of <code>maxItems</code> to the   JSON Schema</li> <li><code>unique_items</code>: for list values, this adds a corresponding validation and an annotation of <code>uniqueItems</code> to the   JSON Schema</li> <li><code>min_length</code>: for string values, this adds a corresponding validation and an annotation of <code>minLength</code> to the   JSON Schema</li> <li><code>max_length</code>: for string values, this adds a corresponding validation and an annotation of <code>maxLength</code> to the   JSON Schema</li> <li><code>allow_mutation</code>: a boolean which defaults to <code>True</code>. When False, the field raises a <code>TypeError</code> if the field is   assigned on an instance.  The model config must set <code>validate_assignment</code> to <code>True</code> for this check to be performed.</li> <li><code>regex</code>: for string values, this adds a Regular Expression validation generated from the passed string and an   annotation of <code>pattern</code> to the JSON Schema</li> </ul>"},{"location":"tutorial/yield/","title":"Generators","text":"<p>Sometimes we want to call something before and after original function call.</p> <p>That purpouse can be reached by using <code>yield</code> keyword.</p>"},{"location":"tutorial/yield/#a-database-dependency-with-yield","title":"A database dependency with yield","text":"<p>For example, you could use this to create a database session and close it after finishing.</p> <p>Only the code prior <code>yield</code> statement is executed before sending a response <pre><code>def dependency():\n    db = DBSession()\n    yield db\n    db.close()\n</code></pre></p> <p>The yielded value is what is injected into original function <pre><code>def dependency():\n    db = DBSession()\n    yield db\n    db.close()\n</code></pre></p> <p>The code following the <code>yield</code> statement is executed after the original function has been called <pre><code>def dependency():\n    db = DBSession()\n    yield db\n    db.close()\n</code></pre></p> <p>Tip</p> <p>As same as a regular depends behavior you can use <code>async</code> and <code>sync</code> declarations both with an <code>async</code> original function and only <code>sync</code> declaration with a <code>sync</code> one.</p> <p>Warning</p> <p>All errors occurs at original function or another dependencies will be raised this place <pre><code>def dependency():\n    db = DBSession()\n    yield db\n    db.close()\n</code></pre> To guarantee <code>db.close()</code> execution use the following code: <pre><code>def dependency():\n    db = DBSession()\n    try:\n        yield db\n    finally:\n        db.close()\n</code></pre></p>"}]}